This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
index.html
LICENSE
package.json
README.md
script.js
specializer.md
style.css
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Dependencies
/node_modules

# Wireit cache
# https://github.com/google/wireit#setup
/.wireit

# Build output
# As specified in your package.json wireit config
/dist
/build

# Log files
logs
*.log
npm-debug.log*

# OS-generated files
.DS_Store
Thumbs.db

# Editor directories
.vscode/
.idea/

# Environment variables
.env
.env.local
.env.*.local
</file>

<file path="LICENSE">
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <https://unlicense.org>
</file>

<file path="package.json">
{
  "name": "specializer",
  "version": "1.0.0",
  "private": true,
  "devDependencies": {
    "typescript": "^5.4.5",
    "wireit": "^0.14.12"
  },
  "scripts": {
    "build": "wireit"
  },
  "wireit": {
    "build": {
      "command": "tsc",
      "files": [
        "src/**/*.ts",
        "tsconfig.json"
      ],
      "output": [
        "dist/**"
      ],
      "clean": "if-file-deleted"
    }
  }
}
</file>

<file path="specializer.md">
[2m
√∞≈∏‚Äú¬¶ Repomix v1.1.0
[22m
[2mNo custom config found at repomix.config.json5, repomix.config.jsonc, repomix.config.json or global config at C:\Users\toast\AppData\Local\Repomix\repomix.config.json5, C:\Users\toast\AppData\Local\Repomix\repomix.config.jsonc, C:\Users\toast\AppData\Local\Repomix\repomix.config.json.
You can add a config file for additional settings. Please check https://github.com/yamadashy/repomix for more information.[22m
[36m√¢¬†‚Ñ¢[39m Collecting files...
</file>

<file path="style.css">
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #eef1f5; /* Light grayish blue */
    color: #333;
    line-height: 1.6;
}

.container {
    max-width: 900px;
    margin: 30px auto;
    background-color: #fff;
    padding: 25px 30px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

h1 {
    color: #2c3e50; /* Dark blue */
    text-align: center;
    margin-bottom: 25px;
    font-size: 2em;
}

h2 {
    color: #3498db; /* Bright blue */
    margin-top: 30px;
    margin-bottom: 15px;
    font-size: 1.5em;
    border-bottom: 2px solid #ecf0f1; /* Light gray border */
    padding-bottom: 8px;
}

label {
    display: block;
    margin-bottom: 8px;
    font-weight: bold;
    color: #555;
}

input[type="text"],
input[type="file"],
textarea {
    width: 100%;
    padding: 12px;
    margin-bottom: 20px;
    border: 1px solid #bdc3c7; /* Light silver */
    border-radius: 5px;
    box-sizing: border-box;
    font-size: 1em;
    transition: border-color 0.3s ease;
}

input[type="text"]:focus,
textarea:focus {
    border-color: #3498db; /* Bright blue focus */
    outline: none;
}

input[type="file"] {
    padding: 10px; /* Specific padding for file input if needed */
    background-color: #f8f9fa;
}

button {
    background-color: #3498db; /* Bright blue */
    color: white;
    padding: 12px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    transition: background-color 0.3s ease;
    margin-right: 10px; /* Space between buttons */
}

button:hover {
    background-color: #2980b9; /* Darker blue */
}

button:disabled {
    background-color: #a5c9e3; /* Lighter, disabled blue */
    cursor: not-allowed;
}

.phase {
    margin-bottom: 35px;
    padding-bottom: 25px;
    border-bottom: 1px solid #ecf0f1; /* Light gray separator */
}

.phase:last-child {
    border-bottom: none;
}

#finalResumeOutput {
    border: 1px solid #ddd;
    padding: 20px;
    min-height: 150px;
    background-color: #fdfdfd; /* Very light gray, almost white */
    border-radius: 5px;
    margin-top: 10px;
}

#generatedCoverLetter {
    border: 1px solid #ddd;
    padding: 15px;
    min-height: 150px;
    background-color: #fdfdfd;
    font-family: monospace; /* Keep monospace for pre-like formatting if needed */
    border-radius: 5px;
    white-space: pre-wrap; /* Ensure cover letter formatting is respected */
}

.hidden {
    display: none;
}

.error-message {
    color: #e74c3c; /* Red */
    background-color: #fbecec;
    border: 1px solid #e74c3c;
    padding: 10px;
    border-radius: 5px;
    margin-bottom: 15px;
    text-align: center;
}

.info-message {
    color: #3498db; /* Blue */
    background-color: #eaf6ff;
    border: 1px solid #3498db;
    padding: 10px;
    border-radius: 5px;
    margin-bottom: 15px;
    text-align: center;
}

.button-group {
    margin-top: 10px;
}

/* Rendered Resume Styles (moved from script.js) */
.resume-render {
    font-family: Arial, sans-serif;
    color: #333;
    padding: 20px;
    border: 1px solid #ccc;
    margin-top: 10px;
    background: #fff;
    border-radius: 5px;
}

.resume-render h1 {
    font-size: 24px;
    margin-bottom: 0;
    color: #2c3e50;
    text-align: left; /* Override general h1 */
}

.resume-render .contact-details {
    font-size: 12px;
    margin-top: 5px;
    color: #555;
}

.resume-render .contact-details a {
    color: #3498db;
    text-decoration: none;
}

.resume-render .contact-details a:hover {
    text-decoration: underline;
}

.resume-render h2 {
    font-size: 18px;
    border-bottom: 2px solid #3498db;
    padding-bottom: 5px;
    margin-top: 20px;
    margin-bottom: 10px;
    color: #3498db;
}

.resume-render .resume-section {
    margin-bottom: 15px;
}

.resume-render .job,
.resume-render .education-entry,
.resume-render .project-entry,
.resume-render .certification-entry,
.resume-render .award-entry {
    margin-bottom: 15px;
}

.resume-render h3 {
    font-size: 16px;
    margin-bottom: 5px;
    color: #34495e;
}

.resume-render .job-subheader,
.resume-render .education-entry em {
    font-size: 13px;
    color: #7f8c8d;
    margin-bottom: 8px;
}

.resume-render ul {
    list-style-type: disc;
    margin-left: 20px;
    padding-left: 0;
}

.resume-render li {
    margin-bottom: 5px;
    line-height: 1.4;
}

.resume-render p {
    line-height: 1.6;
    margin-bottom: 10px;
}
</file>

<file path="README.md">
# AI Resume Specializer & Cover Letter Generator

This application helps you tailor your resume and generate a cover letter for specific job applications using the power of Large Language Models (LLMs). You can choose between Google Gemini, OpenAI (ChatGPT), and Anthropic Claude to power the generation process.

## Features

*   **Resume Upload:** Upload your existing resume in PDF (.pdf) or Word (.docx) format.
*   **Job Description Input:** Paste the job description you're applying for.
*   **LLM Selection:** Choose your preferred LLM provider:
    *   Google Gemini
    *   OpenAI (ChatGPT)
    *   Anthropic Claude
*   **API Key Management:** Input your API key for the chosen provider. The application also allows you to specify the model name you wish to use (pre-filled with common defaults).
*   **Local Storage:** Your selected LLM, API keys, and model names are saved in your browser's `localStorage` for convenience, so you don't have to re-enter them every time.
*   **Resume Parsing:** The application parses your resume's text and converts it into a structured JSON format. You can view and edit this JSON before further processing.
*   **AI-Powered Tailoring:**
    *   **Tailored Resume:** Generates a version of your resume with content (summary, experience) specifically rephrased and highlighted to match the job description.
    *   **Tailored Cover Letter:** Creates a draft cover letter based on your resume and the target job.
*   **Interactive Display:** View the tailored resume (rendered as HTML) and the generated cover letter directly in the app.
*   **Downloadable Outputs:** Download your tailored resume and cover letter as styled HTML files, ready for review or further editing.

## How to Use

1.  **Select LLM Provider:**
    *   Use the "Choose LLM Provider" dropdown to select either Google Gemini, OpenAI, or Anthropic Claude.
2.  **Enter API Key & Model Name:**
    *   The configuration section for your selected LLM will appear.
    *   Enter your API Key in the designated field.
    *   The "Model Name" field will be pre-filled with a common model (e.g., `gemini-1.5-flash-latest`, `gpt-3.5-turbo`, `claude-3-haiku-20240307`). You can change this if you want to use a different model from that provider.
3.  **Upload Resume:**
    *   In the "Phase 1: Parse Resume to JSON" section, click "Choose File" and select your resume (.pdf or .docx).
    *   The application will extract the text and use the selected LLM to parse it into a JSON structure. This JSON will appear in the "Parsed Resume JSON (Editable)" textarea.
    *   You can manually edit this JSON if needed (e.g., to correct parsing errors or add missing information).
4.  **Paste Job Description:**
    *   In the "Phase 2: Tailor Resume & Generate Cover Letter" section, paste the full job description into the "Paste Job Description" textarea.
5.  **Generate:**
    *   Click the "Generate Tailored Resume & Cover Letter" button.
    *   The application will use the selected LLM to process your resume JSON and the job description.
6.  **Review Output:**
    *   The "Final Tailored Resume" section will display the AI-generated resume, rendered as HTML.
    *   The "Generated Cover Letter" textarea will show the AI-generated cover letter text.
7.  **Download:**
    *   Click "Download Resume (HTML)" to save the tailored resume.
    *   Click "Download Cover Letter (HTML)" to save the generated cover letter. Both will be saved as HTML files that attempt to use the application's styling.
8.  **Clear All:**
    *   Use the "Clear All & Start Over" button to reset all input fields, output areas, and clear stored API keys/settings from `localStorage`.

## Getting API Keys

You'll need an API key from the LLM provider you choose to use.

*   **Google Gemini:**
    1.  Go to [Google AI Studio](https://aistudio.google.com/).
    2.  Sign in with your Google account.
    3.  Click "Get API key" and follow the instructions to create a new API key.
    4.  A common model suitable for many tasks (and often with a free tier for initial usage) is `gemini-1.5-flash-latest`.

*   **OpenAI (ChatGPT):**
    1.  Go to the [OpenAI Platform](https://platform.openai.com/).
    2.  Sign up or log in.
    3.  Navigate to the "API keys" section in your account settings (usually found by clicking your organization or profile icon).
    4.  Create a new secret key. **Copy it immediately and store it safely, as OpenAI will not show it to you again.**
    5.  A popular and cost-effective model is `gpt-3.5-turbo`. More advanced models like `gpt-4` or `gpt-4o` are also available but typically incur higher costs.

*   **Anthropic Claude:**
    1.  Go to the [Anthropic Console](https://console.anthropic.com/).
    2.  Sign up or log in.
    3.  Navigate to "Account" (often in the top right or left sidebar) and then find the "API Keys" section.
    4.  Create a new API key.
    5.  A fast and capable model, often with a good balance of performance and cost (and sometimes a free tier), is `claude-3-haiku-20240307`. Other models in the Claude 3 family include `claude-3-sonnet-20240229` and `claude-3-opus-20240229`.
    6.  *Note:* The application automatically includes the required `anthropic-version` header (e.g., `2023-06-01`) for Claude API calls.

**Important Note on Free Models & Model Names:**
The model names provided above (e.g., `gemini-1.5-flash-latest`, `gpt-3.5-turbo`, `claude-3-haiku-20240307`) are examples of models often available with free introductory tiers or suitable for development purposes *at the time of this writing*. The availability, naming, and terms of free tiers can change frequently. Please always consult the LLM provider's official website, documentation, and pricing pages for the most current information on available models, their capabilities, and associated costs. The input fields in this application allow you to specify any model name compatible with the selected provider's API.

## ‚ö†Ô∏è Security Warning

**IMPORTANT:** This application stores your API keys in your browser's `localStorage`. `localStorage` is specific to your browser on your computer but is **not a secure vault for sensitive data** if:
*   You are using a shared or public computer.
*   Your browser has been compromised by malicious extensions or software.

For personal use on your own trusted computer, storing API keys in `localStorage` can be convenient. However, be aware of the risks. **Avoid using this application with your API keys on public or untrusted machines.** If you are concerned, use it only with temporary or restricted-use API keys, or clear your keys after each session using the "Clear All & Start Over" button.

## Technical Notes

*   This is a client-side (frontend-only) application built with HTML, CSS, and vanilla JavaScript.
*   It uses [pdf.js](https://mozilla.github.io/pdf.js/) for extracting text from PDF files locally in your browser.
*   It uses [Mammoth.js](https://github.com/mwilliamson/mammoth.js) for extracting text from .docx files locally in your browser.
*   All interactions with LLM APIs are made directly from your browser to the respective provider's servers. No backend server for this application is involved in processing your data or API keys beyond what your browser sends to the LLM.
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Resume Generator & Tailor</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="container">
        <h1>AI Resume Generator & Tailor</h1>

        <div id="messageArea">
            <!-- Error messages or info messages will be displayed here -->
        </div>

        <div class="phase">
            <h2>Settings: Choose LLM & API Keys</h2>
            <div>
                <label for="llmSelection">Choose LLM Provider:</label>
                <select id="llmSelection">
                    <option value="gemini" selected>Google Gemini</option>
                    <option value="openai">OpenAI (ChatGPT)</option>
                    <option value="claude">Anthropic Claude</option>
                </select>
            </div>

            <div id="geminiConfig" class="llm-config-group">
                <label for="geminiApiKey">Google AI Studio API Key:</label>
                <input type="text" id="geminiApiKey" name="geminiApiKey" placeholder="Enter your Gemini API key">
                <label for="geminiModelName">Gemini Model Name:</label>
                <input type="text" id="geminiModelName" name="geminiModelName" value="gemini-2.5-flash">
            </div>

            <div id="openaiConfig" class="llm-config-group" style="display: none;">
                <label for="openaiApiKey">OpenAI API Key:</label>
                <input type="text" id="openaiApiKey" name="openaiApiKey" placeholder="Enter your OpenAI API key">
                <label for="openaiModelName">OpenAI Model Name:</label>
                <input type="text" id="openaiModelName" name="openaiModelName" value="gpt-3.5-turbo">
            </div>

            <div id="claudeConfig" class="llm-config-group" style="display: none;">
                <label for="claudeApiKey">Anthropic API Key:</label>
                <input type="text" id="claudeApiKey" name="claudeApiKey" placeholder="Enter your Anthropic API key">
                <label for="claudeModelName">Claude Model Name:</label>
                <input type="text" id="claudeModelName" name="claudeModelName" value="claude-3-haiku-20240307">
                <p style="font-size: 0.8em; margin-top: 5px;">Note: Claude API requires Anthropic-Version header (e.g.,
                    2023-06-01). This is handled by the script.</p>
            </div>
        </div>

        <div class="phase">
            <h2>Phase 1: Parse Resume to JSON</h2>
            <div>
                <label for="resumeFile">Upload Resume (.pdf or .docx):</label>
                <input type="file" id="resumeFile" name="resumeFile" accept=".pdf,.docx">
            </div>
            <div>
                <label for="parsedResumeJson">Parsed Resume JSON (Editable):</label>
                <textarea id="parsedResumeJson" rows="15" placeholder="Parsed JSON will appear here..."></textarea>
            </div>
        </div>

        <div class="phase">
            <h2>Phase 2: Tailor Resume & Generate Cover Letter</h2>
            <div>
                <label for="jobDescription">Paste Job Description:</label>
                <textarea id="jobDescription" rows="10" placeholder="Paste job description here..."></textarea>
            </div>
            <div class="button-group">
                <button id="generateTailoredResumeAndCoverLetter">Generate Tailored Resume & Cover Letter</button>
                <button id="clearAllButton" type="button">Clear All & Start Over</button>
            </div>
        </div>

        <div class="phase">
            <h2>Final Tailored Resume</h2>
            <div id="finalResumeOutput">
                <!-- Rendered HTML resume will appear here -->
            </div>
            <button id="downloadResumeButton" type="button" style="margin-top: 10px;">Download Resume (PDF)</button>
        </div>

        <div class="phase">
            <h2>Generated Cover Letter</h2>
            <textarea id="generatedCoverLetter" rows="15" placeholder="Generated cover letter will appear here..."
                readonly></textarea>
            <button id="downloadCoverLetterButton" type="button" style="margin-top: 10px;">Download Cover Letter
                (HTML)</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.5.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script type="module" src="script.js"></script>
</body>

</html>
</file>

<file path="script.js">
import { GoogleGenerativeAI } from "https://cdn.jsdelivr.net/npm/@google/generative-ai/+esm";

// Ensure pdfjsLib is available
if (typeof window.pdfjsLib === 'undefined') {
    console.error("pdf.js library is not loaded correctly.");
    // Potentially display an error to the user on the page
} else {
    window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
}

// Ensure mammoth is available
if (typeof window.mammoth === 'undefined') {
    console.error("mammoth.js library is not loaded correctly.");
    // Potentially display an error to the user on the page
}


document.addEventListener('DOMContentLoaded', () => {
    console.log("DOM Content Loaded");

    // Element selectors
    const llmSelection = document.getElementById('llmSelection');
    const geminiConfigDiv = document.getElementById('geminiConfig');
    const openaiConfigDiv = document.getElementById('openaiConfig');
    const claudeConfigDiv = document.getElementById('claudeConfig');

    const geminiApiKeyInput = document.getElementById('geminiApiKey');
    const geminiModelNameInput = document.getElementById('geminiModelName');
    const openaiApiKeyInput = document.getElementById('openaiApiKey');
    const openaiModelNameInput = document.getElementById('openaiModelName');
    const claudeApiKeyInput = document.getElementById('claudeApiKey');
    const claudeModelNameInput = document.getElementById('claudeModelName');

    const resumeFileInput = document.getElementById('resumeFile');
    const parsedResumeJsonTextarea = document.getElementById('parsedResumeJson');
    const jobDescriptionTextarea = document.getElementById('jobDescription');
    const generateButton = document.getElementById('generateTailoredResumeAndCoverLetter');
    const finalResumeOutputDiv = document.getElementById('finalResumeOutput');
    const generatedCoverLetterTextarea = document.getElementById('generatedCoverLetter');
    const messageArea = document.getElementById('messageArea');
    const clearAllButton = document.getElementById('clearAllButton');

    // --- LLM Configuration and API Key Storage ---
    const configInputs = {
        gemini: { apiKey: geminiApiKeyInput, model: geminiModelNameInput, div: geminiConfigDiv },
        openai: { apiKey: openaiApiKeyInput, model: openaiModelNameInput, div: openaiConfigDiv },
        claude: { apiKey: claudeApiKeyInput, model: claudeModelNameInput, div: claudeConfigDiv }
    };

    function loadLLMSettings() {
        const selectedLLM = localStorage.getItem('selectedLLM') || 'gemini';
        llmSelection.value = selectedLLM;

        for (const service in configInputs) {
            const apiKey = localStorage.getItem(`${service}ApiKey`);
            const modelName = localStorage.getItem(`${service}ModelName`);
            if (apiKey) configInputs[service].apiKey.value = apiKey;
            if (modelName) configInputs[service].model.value = modelName; // Load even if default is set in HTML
        }
        updateLLMConfigVisibility(selectedLLM);
        showMessage("LLM settings and API keys loaded from local storage.", 'info');
        setTimeout(clearMessage, 3000);
    }

    function saveLLMSetting(service, type, value) { // type can be 'ApiKey' or 'ModelName'
        localStorage.setItem(`${service}${type}`, value);
    }

    function updateLLMConfigVisibility(selectedLLM) {
        ['gemini', 'openai', 'claude'].forEach(service => {
            configInputs[service].div.style.display = (service === selectedLLM) ? 'block' : 'none';
        });
    }

    llmSelection.addEventListener('change', (e) => {
        const selectedLLM = e.target.value;
        localStorage.setItem('selectedLLM', selectedLLM);
        updateLLMConfigVisibility(selectedLLM);
    });

    ['gemini', 'openai', 'claude'].forEach(service => {
        configInputs[service].apiKey.addEventListener('input', (e) => saveLLMSetting(service, 'ApiKey', e.target.value.trim()));
        configInputs[service].model.addEventListener('input', (e) => saveLLMSetting(service, 'ModelName', e.target.value.trim()));
    });

    loadLLMSettings(); // Load settings on startup

    // --- Utility functions for messages and loading states ---
    function showMessage(text, type = 'info') {
        messageArea.innerHTML = `<div class="${type}-message">${text}</div>`;
    }

    function clearMessage() {
        messageArea.innerHTML = '';
    }

    function setLoadingState(isLoading) {
        generateButton.disabled = isLoading;
        resumeFileInput.disabled = isLoading;
        if (isLoading) {
            if (document.activeElement === generateButton) {
                showMessage("Processing your request, please wait...", 'info');
            } else if (document.activeElement === resumeFileInput || (event && event.target === resumeFileInput)) {
                showMessage("Processing file, please wait...", 'info');
            }
        } else {
            // Keep message if it's an error, otherwise clear it
            if (!messageArea.querySelector('.error-message')) {
                clearMessage();
            }
        }
    }

    // --- Clear All Button ---
    clearAllButton.addEventListener('click', () => {
        resumeFileInput.value = ''; // Clears the selected file
        parsedResumeJsonTextarea.value = '';
        jobDescriptionTextarea.value = '';
        finalResumeOutputDiv.innerHTML = '';
        generatedCoverLetterTextarea.value = '';

        ['gemini', 'openai', 'claude'].forEach(service => {
            configInputs[service].apiKey.value = '';
            // Reset model to default or clear it if you prefer
            // For now, let's reset to HTML defaults if they exist, or clear
            const defaultModel = document.getElementById(`${service}ModelName`).defaultValue || '';
            configInputs[service].model.value = defaultModel;

            localStorage.removeItem(`${service}ApiKey`);
            localStorage.removeItem(`${service}ModelName`);
        });
        // localStorage.removeItem('selectedLLM'); // Optionally reset LLM selection
        // llmSelection.value = 'gemini'; // Optionally reset to default
        // updateLLMConfigVisibility('gemini');


        clearMessage();
        showMessage("All fields and stored API keys/settings cleared.", 'info');
        setTimeout(clearMessage, 3000);
    });


    // --- Phase 1: Resume Parsing ---
    resumeFileInput.addEventListener('change', async (event) => {
        try { // Outer try-catch for the entire event handler
            const file = event.target.files[0];
            clearMessage();
            if (!file) {
                return;
            }

            finalResumeOutputDiv.innerHTML = "";
            generatedCoverLetterTextarea.value = "";
            parsedResumeJsonTextarea.value = "";

            // API key and model will be checked by getCurrentLLMConfig within callLLMAPI
            // No need to get apiKey here directly anymore.

            setLoadingState(true);
            parsedResumeJsonTextarea.value = "Extracting text from file...";

            // Inner try-catch specifically for file processing and API call
            try {
                let rawText = '';
                if (file.type === "application/pdf") {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        rawText += textContent.items.map(item => item.str).join(' ') + '\n';
                    }
                } else if (file.name.endsWith(".docx")) {
                    const arrayBuffer = await file.arrayBuffer();
                    const result = await window.mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                    rawText = result.value;
                } else {
                    parsedResumeJsonTextarea.value = "Error: Unsupported file type. Please upload .pdf or .docx";
                    showMessage("Error: Unsupported file type. Please upload .pdf or .docx", 'error');
                    setLoadingState(false); // Ensure loading state is reset
                    return;
                }

                if (!rawText.trim()) {
                    parsedResumeJsonTextarea.value = "Error: Could not extract text from file. The file might be empty or corrupted.";
                    showMessage("Error: Could not extract text from file. The file might be empty or corrupted.", 'error');
                    setLoadingState(false); // Ensure loading state is reset
                    return;
                }

                const jsonSchema = {
                    contactInfo: { name: "string", email: "string", phone: "string", linkedin: "string (optional)", github: "string (optional)", portfolio: "string (optional)" },
                    summary: "string",
                    experience: [{ jobTitle: "string", company: "string", location: "string (optional)", dates: "string (e.g., MM/YYYY - MM/YYYY or Present)", duties: ["string"] }],
                    education: [{ institution: "string", degree: "string", graduationDate: "string (e.g., MM/YYYY or Expected MM/YYYY)", location: "string (optional)", details: "string (optional, e.g., GPA, honors)" }],
                    skills: {
                        technical: ["string"],
                        soft: ["string"],
                        other: ["string (optional)"]
                    },
                    projects: [{ name: "string", description: "string", technologies: ["string"], link: "string (optional)" }],
                    certifications: [{ name: "string", issuingOrganization: "string", date: "string (optional)" }],
                    awards: [{ name: "string", organization: "string", date: "string (optional)" }]
                };

                const parserPrompt = `Analyze the following resume text and convert it into a JSON object with this exact structure: ${JSON.stringify(jsonSchema, null, 2)}. Ensure all string values are properly escaped. Here is the text: \n\n${rawText}`;

                showMessage("Sending to AI for parsing...", 'info');
                parsedResumeJsonTextarea.value = "Sending to AI for parsing...";
                // const parsedJson = await callGeminiAPI(apiKey, parserPrompt); // Old call
                const parsedJson = await callLLMAPI(parserPrompt); // New call
                parsedResumeJsonTextarea.value = parsedJson;
                showMessage("Resume parsed successfully. You can now edit the JSON if needed.", 'info');

            } catch (error) {
                console.error("Error during Phase 1 processing (file reading/API call):", error);
                const userErrorMessage = `Error during file processing: ${error.message}. Check console for more details.`;
                parsedResumeJsonTextarea.value = userErrorMessage;
                // Specific error messages are now handled more generically by callLLMAPI or its helper
                showMessage(userErrorMessage, 'error');
            } finally {
                setLoadingState(false);
            }
        } catch (e) { // Catch errors from the outer try-catch
            console.error("Unexpected error in resume file input handler:", e);
            showMessage(`An unexpected error occurred: ${e.message}. Please check the console.`, 'error');
            setLoadingState(false); // Ensure loading state is reset
        }
    });

    // --- Phase 2: Tailoring and Cover Letter ---
    generateButton.addEventListener('click', async () => {
        try { // Outer try-catch for the entire event handler
            clearMessage();
            // const apiKey = apiKeyInput.value.trim(); // Old way
            const resumeJsonString = parsedResumeJsonTextarea.value.trim();
            const jobDesc = jobDescriptionTextarea.value.trim();

            // API key will be checked by getCurrentLLMConfig within callLLMAPI
            if (!resumeJsonString) {
                showMessage("Parsed Resume JSON is missing. Please upload a resume first.", 'error');
                return;
            }
            if (!jobDesc) {
                showMessage("Job Description is missing. Please paste it in the textarea.", 'error');
                return;
            }

            setLoadingState(true);
            finalResumeOutputDiv.innerHTML = "";
            generatedCoverLetterTextarea.value = "";
            showMessage("Generating tailored resume and cover letter...", 'info');

            // Inner try-catch for API calls and JSON parsing
            try {
                let resumeJson;
                try {
                    resumeJson = JSON.parse(resumeJsonString);
                } catch (e) {
                    showMessage("The Parsed Resume JSON is not valid. Please correct it before proceeding.", 'error');
                    setLoadingState(false);
                    return;
                }

                const tailorPrompt = `Act as a career coach. Rewrite the content of the following resume.json (especially "summary" and "experience" sections, and "duties" within experience) to align perfectly with the keywords and requirements of the provided job description. Return a JSON object with the *exact same structure* as the input resume.json. Do not add new top-level keys or change the existing schema. Ensure all string values are properly escaped. \n\nResume JSON:\n${JSON.stringify(resumeJson, null, 2)}\n\nJob Description:\n${jobDesc}`;

                // const tailoredResumeJsonString = await callGeminiAPI(apiKey, tailorPrompt); // Old
                const tailoredResumeJsonString = await callLLMAPI(tailorPrompt); // New
                let tailoredResumeJson;
                try {
                    tailoredResumeJson = JSON.parse(tailoredResumeJsonString);
                } catch (e) {
                    console.error("Error parsing tailored resume JSON from API:", e, "\nReceived:", tailoredResumeJsonString);
                    const RerrorMsg = "Error: AI returned an invalid JSON format for the tailored resume. Check console for details.";
                    showMessage(RerrorMsg, 'error');
                    finalResumeOutputDiv.innerHTML = RerrorMsg;
                    generatedCoverLetterTextarea.value = "Could not generate cover letter due to resume tailoring error.";
                    setLoadingState(false);
                    return;
                }

                renderHtmlResume(tailoredResumeJson, finalResumeOutputDiv);
                showMessage("Tailored resume generated. Now generating cover letter...", 'info');

                const coverLetterPrompt = `Generate a professional and customized cover letter based on the following tailored resume JSON and job description. The cover letter should be ready to send, filling in all placeholders. If critical information like the hiring manager's name or specific company address is missing and cannot be inferred, mention that such details might need to be added by the user. The tone should be enthusiastic and professional. Highlight key achievements and skills from the resume that match the job description. \n\nTailored Resume JSON:\n${JSON.stringify(tailoredResumeJson, null, 2)}\n\nJob Description:\n${jobDesc}`;

                // const coverLetterText = await callGeminiAPI(apiKey, coverLetterPrompt); // Old
                const coverLetterText = await callLLMAPI(coverLetterPrompt); // New
                generatedCoverLetterTextarea.value = coverLetterText;
                showMessage("Tailored resume and cover letter generated successfully!", 'info');

            } catch (error) {
                console.error("Error during Phase 2 processing (API calls/JSON parsing):", error);
                const userErrorMessageP2 = `Error during tailoring/generation: ${error.message}. Check console for details.`;
                showMessage(userErrorMessageP2, 'error');
                finalResumeOutputDiv.innerHTML = `Error: ${error.message}`;
                generatedCoverLetterTextarea.value = `Error: ${error.message}`;
                // Specific error messages are now handled more generically by callLLMAPI
            } finally {
                setLoadingState(false);
            }
        } catch (e) { // Catch errors from the outer try-catch
            console.error("Unexpected error in generate button click handler:", e);
            showMessage(`An unexpected error occurred: ${e.message}. Please check the console.`, 'error');
            setLoadingState(false); // Ensure loading state is reset
        }
    });

    // --- Helper to get current LLM configuration ---
    function getCurrentLLMConfig() {
        const selectedService = llmSelection.value;
        const apiKey = configInputs[selectedService].apiKey.value.trim();
        const modelName = configInputs[selectedService].model.value.trim();

        if (!apiKey) {
            showMessage(`API Key for ${selectedService.toUpperCase()} is missing. Please enter it in the settings.`, 'error');
            throw new Error(`API Key for ${selectedService.toUpperCase()} is missing.`);
        }
        if (!modelName) {
            // This case should ideally be prevented by having default values or validation
            showMessage(`Model Name for ${selectedService.toUpperCase()} is missing. Please enter it in the settings.`, 'error');
            throw new Error(`Model Name for ${selectedService.toUpperCase()} is missing.`);
        }
        return { service: selectedService, apiKey, modelName };
    }

    // --- Unified LLM API Call Function ---
    async function callLLMAPI(promptText) {
        const { service, apiKey, modelName } = getCurrentLLMConfig(); // This will throw if key/model is missing

        try {
            let content = "";
            if (service === 'gemini') {
                // Uses GoogleGenerativeAI SDK
                const genAI = new GoogleGenerativeAI(apiKey);
                const model = genAI.getGenerativeModel({ model: modelName });
                const result = await model.generateContent(promptText);
                const response = await result.response;
                content = response.text();

            } else if (service === 'openai') {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages: [{ role: "user", content: promptText }],
                        temperature: 0.7 // Adjust as needed
                    })
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("OpenAI API Error:", errorData);
                    throw new Error(`OpenAI API Error: ${errorData.error?.message || response.statusText}`);
                }
                const data = await response.json();
                content = data.choices[0]?.message?.content || "";

            } else if (service === 'claude') {
                // Anthropic Claude (Messages API)
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: modelName,
                        max_tokens: 3000, // Adjust as needed, Claude requires max_tokens
                        messages: [{ role: "user", content: promptText }]
                    })
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Claude API Error:", errorData);
                    throw new Error(`Claude API Error: ${errorData.error?.message || response.statusText}`);
                }
                const data = await response.json();
                content = data.content[0]?.text || "";
            }

            // Clean the response if it's wrapped in ```json ... ``` or ``` ... ```
            // This is a common way LLMs return JSON, so good to keep.
            let cleanedText = content.replace(/^```json\s*([\s\S]*?)\s*```$/, '$1');
            cleanedText = cleanedText.replace(/^```([\s\S]*?)```$/, '$1');
            return cleanedText.trim();

        } catch (error) {
            console.error(`Error calling ${service.toUpperCase()} API:`, error);
            // More specific error messages based on common issues
            if (error.message.includes("API key not valid") || error.message.includes("Incorrect API key")) {
                throw new Error(`The API key for ${service.toUpperCase()} is not valid. Please check and try again.`);
            } else if (error.message.includes("model not found") || error.message.includes("Invalid model")) {
                throw new Error(`The model name "${modelName}" for ${service.toUpperCase()} could not be found or is invalid.`);
            } else if (error.message.includes("quota") || error.message.includes("limit")) {
                throw new Error(`You may have exceeded your quota or rate limit for the ${service.toUpperCase()} API.`);
            }
            throw error; // Re-throw other errors to be caught by the caller
        }
    }

    // --- Render HTML Resume ---
    function renderHtmlResume(resumeJson, outputElement) {
        outputElement.innerHTML = ''; // Clear previous content (like "Generating...")

        if (!resumeJson || typeof resumeJson !== 'object') {
            outputElement.innerHTML = "<p>Error: No resume data to display or data is not in the correct format.</p>";
            return;
        }

        let html = `<div class="resume-render">`;

        // Contact Info
        if (resumeJson.contactInfo) {
            const ci = resumeJson.contactInfo;
            html += `<header class="resume-header">`;
            if (ci.name) html += `<h1>${ci.name}</h1>`;
            let contactDetails = [];
            if (ci.email) contactDetails.push(`<a href="mailto:${ci.email}">${ci.email}</a>`);
            if (ci.phone) contactDetails.push(ci.phone);
            if (ci.linkedin) contactDetails.push(`<a href="${ci.linkedin}" target="_blank">LinkedIn</a>`);
            if (ci.github) contactDetails.push(`<a href="${ci.github}" target="_blank">GitHub</a>`);
            if (ci.portfolio) contactDetails.push(`<a href="${ci.portfolio}" target="_blank">Portfolio</a>`);
            if (contactDetails.length > 0) html += `<p class="contact-details">${contactDetails.join(' | ')}</p>`;
            html += `</header>`;
        }

        // Summary
        if (resumeJson.summary) {
            html += `<section class="resume-section"><h2>Summary</h2><p>${resumeJson.summary}</p></section>`;
        }

        // Experience
        if (resumeJson.experience && resumeJson.experience.length > 0) {
            html += `<section class="resume-section"><h2>Experience</h2>`;
            resumeJson.experience.forEach(exp => {
                html += `<div class="job">`;
                html += `<h3>${exp.jobTitle || ''} at ${exp.company || ''}</h3>`;
                let subHeader = [];
                if (exp.location) subHeader.push(exp.location);
                if (exp.dates) subHeader.push(exp.dates);
                if (subHeader.length > 0) html += `<p class="job-subheader"><em>${subHeader.join(' | ')}</em></p>`;
                if (exp.duties && exp.duties.length > 0) {
                    html += `<ul>`;
                    exp.duties.forEach(duty => html += `<li>${duty}</li>`);
                    html += `</ul>`;
                }
                html += `</div>`;
            });
            html += `</section>`;
        }

        // Education
        if (resumeJson.education && resumeJson.education.length > 0) {
            html += `<section class="resume-section"><h2>Education</h2>`;
            resumeJson.education.forEach(edu => {
                html += `<div class="education-entry">`;
                html += `<h3>${edu.degree || ''} - ${edu.institution || ''}</h3>`;
                let eduDetails = [];
                if (edu.location) eduDetails.push(edu.location);
                if (edu.graduationDate) eduDetails.push(`Graduated: ${edu.graduationDate}`);
                if (edu.details) eduDetails.push(edu.details);
                if (eduDetails.length > 0) html += `<p><em>${eduDetails.join(' | ')}</em></p>`;
                html += `</div>`;
            });
            html += `</section>`;
        }

        // Skills
        if (resumeJson.skills) {
            html += `<section class="resume-section"><h2>Skills</h2>`;
            const s = resumeJson.skills;
            if (s.technical && s.technical.length > 0) html += `<p><strong>Technical:</strong> ${s.technical.join(', ')}</p>`;
            if (s.soft && s.soft.length > 0) html += `<p><strong>Soft:</strong> ${s.soft.join(', ')}</p>`;
            if (s.other && s.other.length > 0) html += `<p><strong>Other:</strong> ${s.other.join(', ')}</p>`;
            html += `</section>`;
        }

        // Projects
        if (resumeJson.projects && resumeJson.projects.length > 0) {
            html += `<section class="resume-section"><h2>Projects</h2>`;
            resumeJson.projects.forEach(proj => {
                html += `<div class="project-entry">`;
                html += `<h3>${proj.name || 'Unnamed Project'}</h3>`;
                if (proj.description) html += `<p>${proj.description}</p>`;
                if (proj.technologies && proj.technologies.length > 0) html += `<p><em>Technologies: ${proj.technologies.join(', ')}</em></p>`;
                if (proj.link) html += `<p><a href="${proj.link}" target="_blank">Project Link</a></p>`;
                html += `</div>`;
            });
            html += `</section>`;
        }

        // Certifications
        if (resumeJson.certifications && resumeJson.certifications.length > 0) {
            html += `<section class="resume-section"><h2>Certifications</h2>`;
            resumeJson.certifications.forEach(cert => {
                html += `<div class="certification-entry">`;
                html += `<p><strong>${cert.name || 'Unnamed Certification'}</strong> - ${cert.issuingOrganization || 'N/A'}`;
                if (cert.date) html += ` (${cert.date})`;
                html += `</p>`;
                html += `</div>`;
            });
            html += `</section>`;
        }

        // Awards
        if (resumeJson.awards && resumeJson.awards.length > 0) {
            html += `<section class="resume-section"><h2>Awards</h2>`;
            resumeJson.awards.forEach(award => {
                html += `<div class="award-entry">`;
                html += `<p><strong>${award.name || 'Unnamed Award'}</strong> - ${award.organization || 'N/A'}`;
                if (award.date) html += ` (${award.date})`;
                html += `</p>`;
                html += `</div>`;
            });
            html += `</section>`;
        }


        html += `</div>`; // end .resume-render
        outputElement.innerHTML = html;

        // Styles for rendered resume are now in style.css
    }
    console.log("Event listeners and functions defined.");

    // --- Download Functionality ---
    function triggerDownload(content, filename, mimeType = 'text/html') {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showMessage(`${filename} download started.`, 'info');
        setTimeout(clearMessage, 3000);
    }

    const downloadResumeButton = document.getElementById('downloadResumeButton');
    const downloadCoverLetterButton = document.getElementById('downloadCoverLetterButton');

    downloadResumeButton.addEventListener('click', () => {
        const resumeHtmlContent = finalResumeOutputDiv.innerHTML;
        if (!resumeHtmlContent.trim() || resumeHtmlContent.startsWith("<p>Error:")) {
            showMessage("No resume content available to download or content contains an error.", 'error');
            return;
        }

        if (typeof html2pdf === 'undefined') {
            showMessage("PDF generation library (html2pdf.js) is not loaded. Please check your internet connection and refresh.", 'error');
            console.error("html2pdf.js is not loaded.");
            return;
        }

        showMessage("Generating PDF, please wait...", 'info');

        const element = finalResumeOutputDiv.querySelector('.resume-render');
        const opt = {
            margin: 0.5,
            filename: 'tailored_resume.pdf',
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: { scale: 2, useCORS: true },
        };
        html2pdf().from(element).set(opt).save();
    });

    downloadCoverLetterButton.addEventListener('click', () => {
        const coverLetterText = generatedCoverLetterTextarea.value;
        if (!coverLetterText.trim()) {
            showMessage("No cover letter content available to download.", 'error');
            return;
        }

        // Make it "pretty" by converting newlines to <br> and wrapping in a styled div
        const prettyCoverLetterHtml = coverLetterText.replace(/\n/g, '<br>');

        const fullHtml = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Generated Cover Letter</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<div class="container">
<div class="resume-render" style="padding: 20px; margin-top:20px;">  <!-- Re-use resume-render for similar styling -->
<h2>Cover Letter</h2>
<p>${prettyCoverLetterHtml}</p>
</div>
</div>
</body>
</html>`;
        triggerDownload(fullHtml, 'generated_cover_letter.html');
    });

    console.log("script.js loaded and parsed.");
})
</file>

</files>
